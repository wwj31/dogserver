// Code generated by excelExport. DO NOT EDIT.
// source. 测试.xlsx

package config

import (
	"encoding/json"
	"fmt"
	"os"
	"path"
)

// array and map
var _FdsaMap = map[int64]*Fdsa{}
var _FdsaArray = []*Fdsa{}

type Fdsa struct {
	data *_Fdsa
}

// 类型结构

type _Fdsa struct {
	Id    int64  // ID
	Test1 string // fuck
}

//ID
func (c *Fdsa) Id() int64 { return c.data.Id }

// fuck
func (c *Fdsa) Test1() string { return c.data.Test1 }

func HasFdsa(key int64) bool {
	_, ok := _FdsaMap[key]
	return ok
}

func GetFdsa(key int64) *Fdsa {
	return _FdsaMap[key]
}

func RangeFdsa(fn func(i int, row *Fdsa) (stop bool)) {
	for i, row := range _FdsaArray {
		if fn(i, row) {
			break
		}
	}
}

func LenFdsa() int { return len(_FdsaArray) }

func init() {
	loadFn["Fdsa"] = loadFdsa
}

func loadFdsa(dir string) error {
	data, err := os.ReadFile(path.Join(dir, "fdsa.json"))
	if err != nil {
		return fmt.Errorf("file=%v read err=%v", err.Error())
	}

	datas := []*_Fdsa{}
	err = json.Unmarshal(data, &datas)
	if err != nil {
		return fmt.Errorf("file=%v parse err=%v", err.Error())
	}

	result_array := make([]*Fdsa, 0, len(datas))
	result_map := make(map[int64]*Fdsa, len(datas))
	for _, row := range datas {
		data := &Fdsa{data: row}
		result_array = append(result_array, data)
		result_map[row.Id] = data
	}
	_FdsaArray = result_array
	_FdsaMap = result_map
	fmt.Printf("%-50v len:%v\n", "Fdsa load finish! ", len(result_array))
	return nil
}
