// Code generated by excelExport. DO NOT EDIT.
// source. 随机名.xlsx

package conf

import (
	"encoding/json"
	"fmt"
	"os"
	"path"
)

// array and map
var _RandNameMap = map[int64]*RandName{}
var _RandNameArray = []*RandName{}

type RandName struct {
	data *_RandName
}

// 类型结构

type _RandName struct {
	Id    int64  // ID
	Name1 string // 姓
	Name2 string // 名
}

//ID
func (c *RandName) Id() int64 { return c.data.Id }

// 姓
func (c *RandName) Name1() string { return c.data.Name1 }

// 名
func (c *RandName) Name2() string { return c.data.Name2 }

func HasRandName(key int64) bool {
	_, ok := _RandNameMap[key]
	return ok
}

func GetRandName(key int64) *RandName {
	return _RandNameMap[key]
}

func RangeRandName(fn func(i int, row *RandName) (stop bool)) {
	for i, row := range _RandNameArray {
		if fn(i, row) {
			break
		}
	}
}

func LenRandName() int { return len(_RandNameArray) }

func init() {
	loadFn["RandName"] = loadRandName
}

func loadRandName(dir string) error {
	data, err := os.ReadFile(path.Join(dir, "RandName.json"))
	if err != nil {
		return fmt.Errorf("file=%v read err=%v", err.Error())
	}

	datas := []*_RandName{}
	err = json.Unmarshal(data, &datas)
	if err != nil {
		return fmt.Errorf("file=%v parse err=%v", err.Error())
	}

	result_array := make([]*RandName, 0, len(datas))
	result_map := make(map[int64]*RandName, len(datas))
	for _, row := range datas {
		data := &RandName{data: row}
		result_array = append(result_array, data)
		result_map[row.Id] = data
	}
	_RandNameArray = result_array
	_RandNameMap = result_map
	fmt.Printf("%-50v len:%v\n", "RandName load finish! ", len(result_array))
	return nil
}
